# 2.4 Combining channels and multiple process outputs  

!!! note "Learning objectives"  

    1. Implement a channel that combines the contents of two channels.  
    2. Implement a process with multiple output files.  
    3. Improve execution logging with process directives and groovy.

> Update learning objectives, check if it was done in the previous lesson  

In this step we will add `03_multiqc.sh` to our workflow. MultiQC is a popular
tool for summarising the outputs of many different bioinformatics tools. It
aggregates results from all our analyses and renders it into a nice report. You can see an
example report [here](https://multiqc.info/examples/rna-seq/multiqc_report).

> May need to be more explicit about what tool outputs we're pulling in 

From the MultiQC [docs](https://multiqc.info/docs/):  

!!! note

    MultiQC doesn’t do any analysis for you - it just finds results from
    other tools that you have already run and generates nice reports.
    
![](img/4.excalidraw.png)

```bash title="03_multiqc.sh"
multiqc --outdir results/ results/
```

`--outdir results/` indicates where to output two MultiQC files:  

1. A directory `multiqc_data` with files needed to generate the report
2. A file `multiqc_report.html` 

`results/` is the input argument and automatically searches for the output
files generated by the `FASTQC` and `QUANTIFICATION` processes.  

## 2.4.1 Adding the `MULTIQC` process  

We will implement MultiQC based off the pipeline 

Add the following MULTIQC process definition after the `QUANTIFICATION` process.
The `script` and `input` follow the MultiQC 
[integration recommendations](https://multiqc.info/docs/usage/pipelines/#nextflow).

```groovy title="main.nf"
process MULTIQC {

  container "quay.io/biocontainers/multiqc:1.19--pyhdfd78af_0"
  publishDir params.outdir, mode: 'copy'

  input:
  path "*"

  output:
    < process outputs >

  script:
  """
  multiqc .
  """
}
```

> Probably need another diagram and explanation on why the script is thw way
it is  

> Refer back to staging from Part 1, and that the channel/`.collect` deals
with this. More stable using channels to deal with paths vs. directory input

From the information above we know that the input for `multiqc` is the 
`results/` directory, specifically, the files and directories within
`results/`. We will need to bring the outputs of the `FASTQC`
(`fastqc_gut_logs/`) and `QUANTIFICATION` (`gut/`) processes into a single
channel as input to `MULTIQC`.  

??? warning "Why you should NOT use the `publishDir` folder as a process input"

    It might make sense to have the `results/` folder (set by `publishDir`) as
    the input to the process here, but it may not exist until the workflow
    finishes. 

    Using the `results/` directory, or `publishDir` as a process input can
    cause downstream processes prematurely, even if the directory is empty or
    incomplete. (In this case, MultiQC might miss some inputs)

    Use **channels** to pass data between processes. Channels enable Nextflow
    to track outputs and ensure that downstream processes only run when all
    required data is ready, maintaining proper worfklow control.

More on this in the next section.  

> Use work directory to explore outputs of a process. How do we know what
outputs of QUANTIFICATION we're trying to capture?

Next, add the `output` definition. 

> Explain why these files are ouput - will be clear with diagram

```groovy title="main.nf" hl_lines="10-11"
process MULTIQC {

  container "quay.io/biocontainers/multiqc:1.19--pyhdfd78af_0"
  publishDir params.outdir, mode: 'copy'

  input:
  path "*"  

  output:
  path "multiqc_report.html"
  path "multiqc_data"

  script:
  """
  multiqc .
  """
}
```

## 2.4.2 Combining channels with operators  

> Add that the goal of this step is to get a tuple 

!!! question "Exercise"

    Which channels output:

    1. `fastqc_gut_logs/`
    2. `gut/`

    ??? note "Solution"

        `fastqc_ch` and `quant_ch`.  

The next few steps will involve chaining together nextflow operators to prepare
the inputs for the correct format for the `MULTIQC` process.  

In the workflow scope, use the 
[`mix`](https://www.nextflow.io/docs/latest/operator.html#mix) operator to
emit the contents of `fastqc_ch` and `quant_ch` in a single channel. View it:  

```groovy title="main.nf" hl_lines="18-20"
// Define the workflow
workflow {

    // Run the index step with the transcriptome parameter
    INDEX(params.transcriptome_file)

    // Define the fastqc input channel
    reads_in = Channel.fromPath(params.reads)
        .splitCsv(header: true)
        .map { row -> [row.sample, file(row.fastq_1), file(row.fastq_2)] }

    // Define the quantification channel for the index files
    transcriptome_index_in = INDEX.out[0]

    // Run the quantification step with the index and reads_in channels
    QUANTIFICATION(transcriptome_index_in, reads_in)

    FASTQC.out[0]
        .mix(QUANTIFICATION[0])
        .view()

}
```

Run the workflow:  

```bash
nextflow run main.nf -resume  
```

The output should look something like:  

```console title="Output"
Launching `main.nf` [stupefied_minsky] DSL2 - revision: 82245ce02b

[de/fef8c4] INDEX              | 1 of 1, cached: 1 ✔
[bb/32a3aa] FASTQC (1)         | 1 of 1, cached: 1 ✔
[a9/000f36] QUANTIFICATION (1) | 1 of 1, cached: 1 ✔
/home/setup2/hello-nextflow/part2/work/bb/32a3aaa5e5fd68265f0f34df1c87a5/fastqc_gut_logs
/home/setup2/hello-nextflow/part2/work/a9/000f3673536d98c8227b393a641871/gut
```  

The outputs have been emitted one after the other, meaning that it will be
processed separately. We need them to be processed together (generated in the
same MultiQC report) so we need to add one more step.  

Add the [`collect`](https://www.nextflow.io/docs/latest/operator.html#collect)
operator to ensure all samples are processed together in the same
process and view the output:  

```groovy title="main.nf" hl_lines="20"
// Define the workflow
workflow {

    // Run the index step with the transcriptome parameter
    INDEX(params.transcriptome_file)

    // Define the fastqc input channel
    reads_in = Channel.fromPath(params.reads)
        .splitCsv(header: true)
        .map { row -> [row.sample, file(row.fastq_1), file(row.fastq_2)] }

    // Define the quantification channel for the index files
    transcriptome_index_in = INDEX.out[0]

    // Run the quantification step with the index and reads_in channels
    QUANTIFICATION(transcriptome_index_in, reads_in)

    FASTQC.out[0]
        .mix(QUANTIFICATION[0])
        .collect()
        .view()

}
```

Run the workflow:  

```bash
nextflow run main.nf -resume  
```

The channel now outputs a single tuple with the two directories.  

```console title="Output"
Launching `main.nf` [small_austin] DSL2 - revision: 6ab927f137

[de/fef8c4] INDEX              | 1 of 1, cached: 1 ✔
[bb/32a3aa] FASTQC (1)         | 1 of 1, cached: 1 ✔
[a9/000f36] QUANTIFICATION (1) | 1 of 1, cached: 1 ✔
[/home/setup2/hello-nextflow/part2/work/bb/32a3aaa5e5fd68265f0f34df1c87a5/fastqc_gut_logs, /home/setup2/hello-nextflow/part2/work/a9/000f3673536d98c8227b393a641871/gut]

```

!!! question "Exercise"

    Now that we have a channel that emits the correct data, remove `.view()`
    and assign the channel to a variable called `multiqc_in`.

    ??? note "Solution"
        
        ```groovy title="main.nf" hl_lines="7 8 11"
            // Define the quantification channel for the index files
            transcriptome_index_in = INDEX.out[0]
        
            // Run the quantification step with the index and reads_in channels
            QUANTIFICATION(transcriptome_index_in, reads_in)
       
            // Define the multiqc input channel
            multiqc_in = FASTQC.out[0]
                .mix(QUANTIFICATION[0])
                .collect()
        
        }
        ```

We are now ready to call the `MULTIQC` process in the `workflow`.  

!!! question "Exercise"

    Add the `MULTIQC` process in the workflow scope with `multiqc_in` as input.

    ??? note "Solution"

        ```groovy title="main.nf" hl_lines="12-17"
            // Define the quantification channel for the index files
            transcriptome_index_in = INDEX.out[0]
        
            // Run the quantification step with the index and reads_in channels
            QUANTIFICATION(transcriptome_index_in, reads_in)
       
            // Define the multiqc input channel
            multiqc_in = FASTQC.out[0]
                .mix(QUANTIFICATION[0])
                .collect()

            /*
             * Generate the analysis report with the outputs
             * from FASTQC and QUANTIFICATION
             */ 
             MULTIQC(multiqc_in)
        
        }
        ```

Run the workflow:  

```bash
nextflow run main.nf -resume  
```

```console title="Output"
Launching `main.nf` [hopeful_swanson] DSL2 - revision: a4304bbe73

[aa/3b8821] INDEX          [100%] 1 of 1, cached: 1 ✔
[c2/baa069] QUANTIFICATION [100%] 1 of 1, cached: 1 ✔
[ad/e49b20] FASTQC         [100%] 1 of 1, cached: 1 ✔
[a3/1f885c] MULTIQC        [100%] 1 of 1 ✔

```

> Inspect `results/multiqc_report.html`, maybe Poll something in the file  

You have a working pipeline for a single paired-end sample!

!!! abstract "Summary"

    In this step you have learned:

        1. How to
        1. How to
        1. How to
        1. How to
        1. How to
