# 2.4 Combining channels and multiple process outputs  

!!! note "Learning objectives"  

    1. Implement a channel that combines the contents of two channels.  
    2. Implement a process with multiple output files.  
    3. Improve execution logging with process directives and groovy.

> Update learning objectives, check if it was done in the previous lesson  

In this step we will add `03_multiqc.sh` to our workflow. MultiQC is a popular
tool for summarising the outputs of many different bioinformatics tools. It
aggregates results from all our analyses and renders it into a nice report. You can see an
example report [here](https://multiqc.info/examples/rna-seq/multiqc_report).

> May need to be more explicit about what tool outputs we're pulling in 

From the MultiQC [docs](https://multiqc.info/docs/):  

!!! note

    MultiQC doesn’t do any analysis for you - it just finds results from
    other tools that you have already run and generates nice reports.
    
![](img/4.excalidraw.png)

```bash title="03_multiqc.sh"
multiqc --outdir results/ results/
```

`--outdir results/` indicates where to output two MultiQC files:  

1. A directory `multiqc_data` with files needed to generate the report
2. A file `multiqc_report.html` 

`results/` is the input argument and automatically searches for the output
files generated by the `FASTQC` and `QUANTIFICATION` processes.  

## 2.4.1 Adding the `MULTIQC` process  

We will implement MultiQC based off the pipeline 
[integration recommendations](https://multiqc.info/docs/usage/pipelines/#nextflow).

Add the following process definition with the `script` and `input` provided:  

```groovy title="main.nf"
process MULTIQC {

  input:
  path "*"

  output:
    < process outputs >

  script:
  """
  multiqc .
  """
}
```

> Probably need another workflow and explanation on why the script is thw way
it is  

> Refer back to staging from day 1, and that the channel/`.collect` deals
with this. More stable using channels to deal with paths vs. directory input

From the information above we know that the input for `multiqc` is the 
`results/` directory, specifically, the files and directories within
`results/`. We will need to bring the outputs of the `FASTQC`
(`fastqc_gut_logs/`) and `QUANTIFICATION` (`gut/`) processes into a single
channel as input to `MULTIQC`.  

??? warning "Why you should NOT use the `publishDir` folder as a process input"

    It might make sense to have the `results/` folder (set by `publishDir`) as
    the input to the process here, but it may not exist until the workflow
    finishes. 

    Using the `results/` directory, or `publishDir` as a process input can
    cause downstream processes prematurely, even if the directory is empty or
    incomplete. (In this case, MultiQC might miss some inputs)

    Use **channels* to pass data between processes. Channels enable Nextflow
    to track outputs and ensure that downstream processes only run when all
    required data is ready, maintaining proper worfklow control.

More on this in the next section.  

> Use work directory to explore outputs of a process. How do we know what
outputs of QUANTIFICATION we're trying to capture?

!!! question "Exercise"

    Add the `output` definition, using the information on the bash script above.

    ??? note "Solution"

        ```groovy title="main.nf"
        process MULTIQC {
          [ directives ]
        
          input:
          path "*"  
        
          output:
          path "multiqc_report.html"
          path "multiqc_data"
        
          script:
          """
          multiqc .
          """
        }
        ```

Add the directives:  

```groovy 
process MULTIQC {

  container "quay.io/biocontainers/multiqc:1.19--pyhdfd78af_0"
  publishDir "results", mode: 'copy'

  input:
  path "*"  

  output:
  path "multiqc_report.html"
  path "multiqc_data"

  script:
  """
  multiqc .
  """
}
```

## 2.4.2 Combining channels with operators  

> Add that the goal of this step is to get a tuple 

!!! question "Exercise"

    Which channels output:

    1. `fastqc_gut_logs/`
    2. `gut/`

    ??? note "Solution"

        `fastqc_ch` and `quant_ch`.  

The next few steps will involve chaining together nextflow operators to prepare
the inputs for the correct format for the `MULTIQC` process.  

In the workflow scope, use the 
[`mix`](https://www.nextflow.io/docs/latest/operator.html#mix) operator to
emit the contents of `fastqc_ch` and `quant_ch` in a single channel. View it:  

```groovy title="main.nf"
    fastqc_ch = FASTQC(read_pairs_ch)
    quant_ch = QUANTIFICATION(index_ch, read_pairs_ch)

    fastqc_ch
        .mix(quant_ch)
        .view()
}
```

Run the workflow:  

```bash
nextflow run main.nf -resume  
```

The output should look something like:  

```console title="Output"
Launching `main.nf` [stupefied_minsky] DSL2 - revision: 82245ce02b

[de/fef8c4] INDEX              | 1 of 1, cached: 1 ✔
[bb/32a3aa] FASTQC (1)         | 1 of 1, cached: 1 ✔
[a9/000f36] QUANTIFICATION (1) | 1 of 1, cached: 1 ✔
/home/setup2/hello-nextflow/day2/work/bb/32a3aaa5e5fd68265f0f34df1c87a5/fastqc_gut_logs
/home/setup2/hello-nextflow/day2/work/a9/000f3673536d98c8227b393a641871/gut
```  

The outputs have been emitted one after the other, meaning that it will be
processed separately. We need them to be processed together (generated in the
same report) so need one more step.  

Add the [`collect`](https://www.nextflow.io/docs/latest/operator.html#collect)
operator to ensure all samples are processed together in the same
process and view the output:  

```groovy title="main.nf"
    fastqc_ch = FASTQC(read_pairs_ch)

    quant_ch
        .mix(fastqc_ch)
        .collect()
        .view()
}
```

Run the workflow:  

```bash
nextflow run main.nf -resume  
```

The channel now outputs a single tuple with the two directories.  

```console title="Output"
Launching `main.nf` [small_austin] DSL2 - revision: 6ab927f137

[de/fef8c4] INDEX              | 1 of 1, cached: 1 ✔
[bb/32a3aa] FASTQC (1)         | 1 of 1, cached: 1 ✔
[a9/000f36] QUANTIFICATION (1) | 1 of 1, cached: 1 ✔
[/home/setup2/hello-nextflow/day2/work/bb/32a3aaa5e5fd68265f0f34df1c87a5/fastqc_gut_logs, /home/setup2/hello-nextflow/day2/work/a9/000f3673536d98c8227b393a641871/gut]

```

!!! question "Exercise"

    Remove `.view()` and `set` the output as `all_qc_ch` 

    ??? note "Solution"
        
        ```groovy title="main.nf"
            quant_ch
                .mix(fastqc_ch)
                .collect()
                .set { all_qc_ch }
        }
        ```

We are now ready to call the process in the `workflow`.  

!!! question "Exercise"

    Add the workflow scope for `MULTIQC` with `all_qc_ch` as input. Do not
    assign this to a variable as it is the final process in our workflow.  

    ??? note "Solution"

```groovy title="main.nf"
    fastqc_ch
        .mix(quant_ch)
        .collect()
        .set { all_qc_ch }

    MULTIQC(all_qc_ch)
}
```

Run the workflow:  

```bash
nextflow run main.nf -resume  
```

```console title="Output"
Launching `main.nf` [hopeful_swanson] DSL2 - revision: a4304bbe73

[aa/3b8821] INDEX          [100%] 1 of 1, cached: 1 ✔
[c2/baa069] QUANTIFICATION [100%] 1 of 1, cached: 1 ✔
[ad/e49b20] FASTQC         [100%] 1 of 1, cached: 1 ✔
[a3/1f885c] MULTIQC        [100%] 1 of 1 ✔

```

> Inspect `results/multiqc_report.html`, maybe Poll something in the file  

You have a working pipeline for a single paired-end sample!

## 2.4.3 Adding a `tag` directive

> Probably move to final lesson

Now that we have an end-to-end workflow, we will add things to help understand
what is being executed. These will be particularly useful when we run more
samples later.  

Add the following tag directives to your `FASTQC` and `QUANTIFICATION`
processes:  

```groovy title="main.nf"
process FASTQC {

    tag "fastqc on ${sample_id}"
    container "quay.io/biocontainers/fastqc:0.12.1--hdfd78af_0"
    publishDir params.outdir, mode: 'copy'

```

```groovy title="main.nf"
process QUANTIFICATION {

    tag "salmon on ${sample_id}"
    container "quay.io/biocontainers/salmon:1.10.1--h7e5ed60_0"
    publishDir params.", mode: 'copy'

```

> Maybe a note on how directives can use the same variable from the input
definition  

Run the workflow:  

```bash
nextflow run main.nf -resume
```

Your output should look like:  

```
[de/fef8c4] INDEX                          | 1 of 1, cached: 1 ✔
[bb/32a3aa] FASTQC (fastqc on gut)         | 1 of 1, cached: 1 ✔
[a9/000f36] QUANTIFICATION (salmon on gut) | 1 of 1, cached: 1 ✔
[2f/f0f05e] MULTIQC                        | 1 of 1, cached: 1 ✔

```

Nothing was re-run, but the execution log now shows the sample that was
processed.

??? example "Advanced exercise"

   Implement `log.info`? `-with-profile`?

!!! abstract "Summary"

    In this step you have learned:

        1. How to
        1. How to
        1. How to
        1. How to
        1. How to
